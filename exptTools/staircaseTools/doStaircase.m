function [dataSum] = doStaircase(display, stairParams, stimParams, trialGenFuncName, priority, logFID, varargin)% [dataSum] = doStaircase(display, stairParams, stimParams, trialGenFuncName, [priority], [logFID], %															['optionFlag1'], ['optionFlag2'], ...)%	display:			(struct)	display parameters%%	stairParams:		(struct)	staircase parameters (see below)%%	stimParams:			(struct)	stimulus parameters%%	trialGenFuncName	(string)	specifies the function called to generate the stimuli.%									This function must exist in the current matlab path and%									must assume the following form (replacing trialGenFuncName%									with the correct function name): %										[trial, data] = trialGenFuncName(display, stimParams, data)%									Use 'data' for whatever you would like to be preserved from%									trial to trial (pre-computed images, colormaps, etc.).%%	priority			(int)		optional- specifies run priority (0-7, 0 is default)%%	logFID				(int)		optional- specifies where log data go- default is the screen.%									if logFID is a vector, each of the files specified will be %									written to.  All files written as text files.%			%	optionFlags			(string)	Specify any number of the following options:%										precomputeFirstTrial:	this option is really only useful%																if your trialGenFunction saves%																stuff in the 'data' structure that%																will save time when building%																subsequent trials.%										precomputeAllTrials:	this option builds all the trials%																ahead of time.  It may take a while%																to do this, especially if you have%																alot of adjustableVarValues!  Also%																note that randomization will be%																systematic- trials in a staircase%																with the same adjustableVarValue%																will have the same randVarValues%																and the same alternativeVarValue.%																You can make things seem more random%																by doing several staircases.  Or, you%																may want to do the precomputing in%																your trialGenFunction and leave this%																option off.%%%%stairParams structure:%%	stairParams.alternativeVarName = 'testPosition';%	stairParams.alternativeVarValues = ['L' 'R'];%		This must be a fieldname of stimParams.  The values are selected from the %		list at random and a trial is counted as 'correct' if the alternative%		index and the response index are the same.  (e.g., if the second%		alternative was presented and the second response of the response set%		was entered, then the trial will be counted as correct.)%%   stairParams.adjustableVarName = 'varName';%		This must be a fieldname of stimParams.  The values are selected%		systematicallly from stairParams.stimLevels according to the rules%		defined by the parameters below.%%   stairParams.adjustableVarStart = [1 1]; %		The length of this vector determines the number of interleaved staircases%		(referred to as numStairs in this file).% 		Each value in this vector is an index into stairParams.adjustableVarStart%		which determines where each of the staircases start.%%	stairParams.adjustableVarValues = [10.^[0:-.1:-2]];%		An 1 x N vector or numStairs x N matrix specifying the N different stimulus%		levels (N can be any value).  If the number of rows is < numStairs, then the %		adjustableVarValues for all subsequent staircases are taken from the levels%		of the last staircase specified (e.g., if it is 1 x N, then all staircases%		will use the same levels).%%	stairParams.randomVars = {'varName' [0:3:9]};	%		This is a cell array that may contain any number of rows, where each row is %		a stimParams field name (the variable you want randomized) and a vector listing%		the possible values.  DoStaircase will randomly assign a value from the list%		to the variable(s) before each trial.%%	stairParams.curStairVars = {'varName', [1 2 3]};	%		This is a cell array that may contain any number of rows, where each row is %		a stimParams field name (the variable you want varied) and a vector listing%		the possible values.  DoStaircase will assign a value from the list%		to the variable(s) before each trial, based on the current staircase.%		That is, the first value will be used when doing a trial for the first%		interleaved staircase, the second value used for the second staircase, etc.%%	stairParams.numCorrectForStep = 2;		%	stairParams.numIncorrectForStep = 1;		%		These two determine how many consecutive correct and how many consecutive%		incorrect responses are needed before adjusting the adjustableVarValue.%%	stairParams.correctStepSize = 2;		%	stairParams.incorrectStepSize = 1;		%		These two determine how many index units (of stairParams.stimLevels) to%		jump with a correct (or incorrect) response sequence that meets the %		criteria defined by stairParams.numCorrectForStep/.numIncorrectForStep.%%	stairParams.maxNumTrials = 100;%	stairParams.maxNumReversals = 10;%		The staircase ends when either of these conditions are met.%%	stairParams.feedback = 'click';%		feedback options: 'none', 'click', 'auditory'.  ('click' clicks when a %		valid response is registered, but does not indicate correct/incorrect.)%		You can also provide feedback through the trial structure, including more%		elaborate visual feedback.%%	stairParams.responseSet = '13';%		This is a string listing acceptable responses (no spaces!)%		Alternative 1 is the first character in this sting, alternative 2 the second,%		and so on.  Do not use q or Q- these characters are special and cause the experient%		to abort.  If this field is omitted, then doStaircase will expect the trial%		to return a response.%%	stairParams.conditionName = {'cond1'; 'cond2'};%		This is a cell array where each row is the condition name for a staircase.%		For example, the first row should contain the condition name for the first%		staircase, the second row the name for the second staircase, and so on.%		If there are fewer rows than staircases, the the staircases without%		specified naems get the name of the last named staircase.  If this field%		is omitted, all staircases get the name of the adjustableVar.%		%% 98/10/08 coded by Bob Dougherty (aka RFD)% 98/10/14 got into a working form by Bob Dougherty (lots of advice from WAP and BTB)% 98/10/20 RFD: added varargin option flags to precompute trials.  Modified 'data' to be%				a cell array so that each interleaved staircases can have their own%				data.  Also, added reversalStimLevel to dataSum.% 98/10/26 RFD: added history field to dataSum (keeps a history of the adjustableVarValue%				presented on each trial).  Also added "save('dataSumTemp', 'dataSum');" %				so that the summary data are not lost in the event of an error or crash.% 98/10/26 RFD: added stairParams.conditionName.% 98/11/02 RFD: fixed precomputeFurstTrial so that it sets the first adjustableVarValue%				before building the trial.% 98/11/04 RFD: Added code to clear the keyboard queue before each trial so that any%				inadvertant keypresses will not count as responses.% 98/11/06 RFD: Fixed the reversal-checking code so that it works properly now!% 98/11/13 RFD: Fixed the reversal-checking code so that it does the right thing%				without bombing when there are more than one interleaved staircases.% 98/11/24 RFD: Fixed the code which checks to see if all the staircases have finished.%				(The error was only evident with multiple staircases- it was ending %				when at least one of the staircases had reached it's stop criteia- now it%				ends only when _all_ the staircases have reached their stop criteria.)% 98/12/04 RFD  Modified the adjustable var algorithm so that it counts as a reversal %               a trial that must be constrained to the adjustable var boundaries.%               (e.g., if the observer hits the minimum adjustable var value and the%               algorithm tries to go even lower, it will count as a reversal.)%               This avoids excessively long runs where the observer has hit the%               upper or lower boundary (because without this fix, no true reversals%               will be tallied).if nargin < 4	error('not enough input arguments- type help doStaircase');endif ~exist('priority', 'var')	priority = 0;endif ~exist('logFID', 'var')	logFID = 1;end% Seed random number generatorClockRandSeed;%if ~isfield(stimParams, stairParams.adjustableVarName)%	error('stairParams.adjustableVarName is not a field of stimParams!');%end% set some defaultsif ~isfield(stairParams, 'numIncorrectBeforeStep')	stairParams.numIncorrectBeforeStep = 1;endif ~isfield(stairParams, 'randomVars')	stairParams.randomVars = {};endif ~isfield(stairParams, 'feedback')	stairParams.feedback = 'auditory';endif ~isfield(stairParams, 'curStairVars')	stairParams.curStairVars = {};endif ~isfield(stairParams, 'conditionName')	if size(stairParams.curStairVars,1)<1		stairParams.conditionName = stairParams.adjustableVarName;	else		for ii=1:length(stairParams.adjustableVarStart)			for jj=1:size(stairParams.curStairVars,1)				stairParams.conditionName{ii,jj*2-1} = stairParams.curStairVars{jj,1};				stairParams.conditionName{ii,jj*2} = ...					stairParams.curStairVars{jj,2}(min(length(stairParams.curStairVars{jj,2}),ii));			end		end	endendnumStairs = length(stairParams.adjustableVarStart);numLevels = size(stairParams.adjustableVarValues, 2);% generate auditory feedbackif isfield(stairParams, 'feedback')	if strcmp(stairParams.feedback,'auditory')		correctSnd = soundFreqSweep(200, 500, .1);		incorrectSnd = soundFreqSweep(500, 200, .1);	elseif  strcmp(stairParams.feedback,'click')		% make them both the same- a click to acknowledge the response		correctSnd = soundFreqSweep(500, 1000, .01);		incorrectSnd = soundFreqSweep(500, 1000, .01);	else		correctSnd = [];		incorrectSnd = [];	endelse	correctSnd = [];	incorrectSnd = [];end% ensure the starting values are in rangeif find(stairParams.adjustableVarStart>numLevels) | find(stairParams.adjustableVarStart<1)	error('Starting values are out of range (range = 1 to number of stim levels).\n');end% initialize all the bookkeeping stuff%data = ones(1,numStairs)*NaN;data = cell(numStairs,1);stairHistory.numTrials = zeros(1,numStairs);stairHistory.numConsecCorrect = zeros(1,numStairs);stairHistory.numConsecIncorrect = zeros(1,numStairs);stairHistory.runDirection = ones(1,numStairs);stairHistory.curAdjustIndex = stairParams.adjustableVarStart;stairHistory.numReversals = zeros(1,numStairs);stairHistory.done = zeros(1,numStairs);numAlternatives = length(stairParams.alternativeVarValues);numLevelVectors = size(stairParams.adjustableVarValues, 1);% initialize the dataSum stufffor curStair=1:numStairs	dataSum(curStair).history = [];	dataSum(curStair).condName = stairParams.conditionName(min(size(stairParams.conditionName,1),curStair),:);	dataSum(curStair).stimLevels = stairParams.adjustableVarValues(min(curStair,numLevelVectors),:);	dataSum(curStair).numTrials = zeros(1,numLevels);	dataSum(curStair).numCorrect = zeros(1,numLevels);	dataSum(curStair).reversalStimLevel = ones(1,stairParams.maxNumReversals)*NaN;end% build the appropriate trialGenFuncName (the same data will be used for all staircases)trialGenFuncName = strcat(trialGenFuncName, '(display, stimParams, data{curStair})');% parse the option flagsfor i=1:length(varargin)	switch varargin{i}		case 'precomputeFirstTrial',			% build the trial			fprintf('Building the first trial for each staircase.\n');			for curStair = 1:numStairs				adjustValue = stairParams.adjustableVarValues(min(curStair,numLevelVectors), 1);				stimParams = setfield(stimParams, stairParams.adjustableVarName, adjustValue);				% set the curStair variable values in the appropriate stimParams fields				for i=1:size(stairParams.curStairVars, 1)					curStairVal(i) = stairParams.curStairVars{i,2}(min(curStair,length(stairParams.curStairVars{i,2})));					stimParams = setfield(stimParams, stairParams.curStairVars{i,1}, curStairVal(i));				end								[trial, data{curStair}] = eval(trialGenFuncName);			end		case 'precomputeAllTrials',			for curStair = 1:numStairs				fprintf('Building trials for staircase %d\n', curStair);				for adjustIndex = 1:numLevels					adjustValue = stairParams.adjustableVarValues(min(curStair,numLevelVectors), adjustIndex);									% set the adjustable variable value					stimParams = setfield(stimParams, stairParams.adjustableVarName, adjustValue);					% set the random variable values in the appropriate stimParams fields					for i=1:size(stairParams.randomVars, 1)						randVal(i) = stairParams.randomVars{i,2}(ceil(rand*length(stairParams.randomVars{i,2})));						stimParams = setfield(stimParams, stairParams.randomVars{i,1}, randVal(i));					end									% set the curStair variable values in the appropriate stimParams fields					for i=1:size(stairParams.curStairVars, 1)						curStairVal(i) = stairParams.curStairVars{i,2}(min(curStair,length(stairParams.curStairVars{i,2})));						stimParams = setfield(stimParams, stairParams.curStairVars{i,1}, curStairVal(i));					end									% randomly choose and then set the alternative variable					altIndex = round(rand*(numAlternatives-1))+1;					altValue = stairParams.alternativeVarValues(altIndex);					stimParams = setfield(stimParams, stairParams.alternativeVarName, altValue);										% build the trial					[trial{curStair, adjustIndex}, data{curStair}] = eval(trialGenFuncName);				end			end		otherwise,			fprintf('\nWARNING: doStaircase unrecognized option flag "%s".\n', varargin(i));	endendfprintf('Ready to begin the trials...\n');% prepare the logfor i=1:length(logFID)	fprintf(logFID(i), '\ncurStair\ttrial\tadjustValue(%s)\tcorrect\taltValue(%s)\t', ...					stairParams.adjustableVarName, stairParams.alternativeVarName);	for j=1:size(stairParams.randomVars, 1)		fprintf(logFID(i), '%s\t', stairParams.randomVars{j,1});	end	for j=1:size(stairParams.curStairVars, 1)		fprintf(logFID(i), '%s\t', stairParams.curStairVars{j,1});	end	fprintf(logFID(i), '\n');endcurStair = round(rand*(numStairs-1))+1;abort = 0;pressKey2Begin(display);% main staircase loopwhile(~all(stairHistory.done) & ~abort)	if exist('trialArray', 'var')		% clear the keyboard queue 		while charAvail getChar; end		% run pre-built trial		response = doTrial(display, trialArray{curStair, stairHistory.curAdjustIndex(curStair)}, priority);	else		% we need to build the trial		adjustValue = stairParams.adjustableVarValues(min(curStair,numLevelVectors), ...														stairHistory.curAdjustIndex(curStair));			correctStepIndex = min(length(stairParams.correctStepSize), stairHistory.numReversals(curStair)+1);		incorrectStepIndex =  min(length(stairParams.incorrectStepSize), stairHistory.numReversals(curStair)+1);			% set the adjustable variable value		stimParams = setfield(stimParams, stairParams.adjustableVarName, adjustValue);		% set the random variable values in the appropriate stimParams fields		for i=1:size(stairParams.randomVars, 1)			randVal(i) = stairParams.randomVars{i,2}(ceil(rand*length(stairParams.randomVars{i,2})));			stimParams = setfield(stimParams, stairParams.randomVars{i,1}, randVal(i));		end						% set the curStair variable values in the appropriate stimParams fields		for i=1:size(stairParams.curStairVars, 1)			curStairVal(i) = stairParams.curStairVars{i,2}(min(curStair,length(stairParams.curStairVars{i,2})));			stimParams = setfield(stimParams, stairParams.curStairVars{i,1}, curStairVal(i));		end							% randomly choose and then set the alternative variable		altIndex = round(rand*(numAlternatives-1))+1;		altValue = stairParams.alternativeVarValues(altIndex);		stimParams = setfield(stimParams, stairParams.alternativeVarName, altValue);				% build the trial		[trial, data{curStair}] = eval(trialGenFuncName);				% clear the keyboard queue 		while charAvail getChar; end				% run the trial		response = doTrial(display, trial, priority);	end		if isfield(stairParams, 'responseSet')		% wait for the response		response = [];		while (isempty(response))			aChar = GetChar;			if aChar == 'q' | aChar == 'Q'				response = -1;				abort = 1;			else				response = find(stairParams.responseSet == aChar);			end		end	end	correct = (response == altIndex);		% update dataSum	if ~abort		stairHistory.numTrials(curStair) = 	stairHistory.numTrials(curStair) + 1;		dataSum(curStair).history(stairHistory.numTrials(curStair)) = adjustValue;		i = find(dataSum(curStair).stimLevels == adjustValue);		if isempty(i)			error('doStaircase: missing stimLevel in dataSum- data may not be valid!');		end		dataSum(curStair).numTrials(i) = dataSum(curStair).numTrials(i) + 1;		if correct			% auditory feedback			if ~isempty(correctSnd) sound(correctSnd); end			dataSum(curStair).numCorrect(i) = dataSum(curStair).numCorrect(i) + 1;			else			if ~isempty(incorrectSnd) sound(incorrectSnd); end		end	end		% print out the log	for i=1:length(logFID)		% incase altValues are characters: num2str(altValue) will work with characters, ints and floats		fprintf(logFID(i), '%d\t%d\t%.4f\t%d\t%s\t', curStair, stairHistory.numTrials(curStair), ...										adjustValue, correct, num2str(altValue));		for j=1:size(stairParams.randomVars, 1)			fprintf(logFID(i), '%.4f\t',  randVal(j));		end		for j=1:size(stairParams.curStairVars, 1)			fprintf(logFID(i), '%.4f\t',  curStairVal(j));		end		fprintf(logFID(i), '\n');	end	% save the dataSum file in case of a crash or error	save('dataSumTemp', 'dataSum');		% adjust the adjustable	if correct		stairHistory.numConsecCorrect(curStair) = stairHistory.numConsecCorrect(curStair) + 1;		stairHistory.numConsecIncorrect(curStair) = 0;		if mod(stairHistory.numConsecCorrect(curStair), stairParams.numCorrectForStep) == 0			stairHistory.curAdjustIndex(curStair) = stairHistory.curAdjustIndex(curStair) ...								+ stairParams.correctStepSize(correctStepIndex);			% check to see if this is a reversal			% if the current run is negative (the 'incorrect' direction), then meeting the			% numConsecCorrect criterion constitutes a reversal.  			if stairHistory.runDirection(curStair) == -1				stairHistory.numReversals(curStair) = stairHistory.numReversals(curStair) + 1;				dataSum(curStair).reversalStimLevel(stairHistory.numReversals(curStair)) = adjustValue;				stairHistory.runDirection(curStair) = +1;			end						end	else		stairHistory.numConsecIncorrect(curStair) = stairHistory.numConsecIncorrect(curStair) + 1;		stairHistory.numConsecCorrect(curStair) = 0;		if mod(stairHistory.numConsecIncorrect(curStair), stairParams.numIncorrectForStep) == 0			stairHistory.curAdjustIndex(curStair) = stairHistory.curAdjustIndex(curStair) ...								+ stairParams.incorrectStepSize(incorrectStepIndex);			% check to see if this is a reversal			% if the current run is positive (the 'correct' direction), then meeting the			% numConsecIncorrect criterion constitutes a reversal.			if stairHistory.runDirection(curStair) == +1				stairHistory.numReversals(curStair) = stairHistory.numReversals(curStair) + 1;				dataSum(curStair).reversalStimLevel(stairHistory.numReversals(curStair)) = adjustValue;				stairHistory.runDirection(curStair) = -1;			end						end	end				% ensure adjustable isn't out of range    % Note that if we have gone out of range, then we should (and do) count this as a    % reversal because it means the observer has hit one of the boundaries.  If we don't    % do something like this, the observer may get stuck at one of the bounds and do many    % unnecessary trials there!	if stairHistory.curAdjustIndex(curStair) > numLevels        % count this as a reversal		stairHistory.numReversals(curStair) = stairHistory.numReversals(curStair) + 1;		dataSum(curStair).reversalStimLevel(stairHistory.numReversals(curStair)) = adjustValue;		% constrain curAdjustIndex to the bounds        stairHistory.curAdjustIndex(curStair) = numLevels;    elseif stairHistory.curAdjustIndex(curStair) < 1        % count this as a reversal		stairHistory.numReversals(curStair) = stairHistory.numReversals(curStair) + 1;		dataSum(curStair).reversalStimLevel(stairHistory.numReversals(curStair)) = adjustValue;		% constrain curAdjustIndex to the bounds        stairHistory.curAdjustIndex(curStair) = 1;	end			% check to see if we are done with this staircase	if stairHistory.numTrials(curStair) >= stairParams.maxNumTrials ...		| stairHistory.numReversals(curStair) >= stairParams.maxNumReversals 		stairHistory.done(curStair) = 1;	end		% adjust the curStair index	%curStair = curStair + 1;	%if curStair > numStairs	%	curStair = 1;	%end		% choose the curStair pseudorandomly, giving preference to staircases that are less done.	completeIndex = stairHistory.numTrials./stairParams.maxNumTrials - randn(size(stairHistory.numTrials))*.2;	curStair = find(completeIndex == min(completeIndex));	curStair = curStair(round(rand*(length(curStair)-1))+1);			% old- used to skip staircases that have finished	% we now let all staircases keep going and just end when all have finished.	%i = find(~stairHistory.done);	%if curStair > max(i)	%	curStair = min(i);	%else	%	curStair = min(i(find(i>=curStair)));	%endend